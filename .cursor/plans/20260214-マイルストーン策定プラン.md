# Nagomi Hub — マイルストーン策定プラン

## 📋 現状分析

### プロジェクト概要

- **名称**: Nagomi Hub
- **コンセプト**: Steam『Spirit City: Lofi Sessions』風の没入型作業用BGM & タスク管理Webサービス
- **技術スタック**: Next.js 15 (App Router) / TypeScript / Tailwind CSS / Framer Motion / React Three Fiber

### 実装済み（すべてモック/フロントエンドのみ）

- ✅ テーマシステム（9テーマ、CSS変数、next-themes）
- ✅ メインゲーム画面（キャラクター表示、ポモドーロタイマーUI、進捗バーUI、環境音コントロールUI）
- ✅ 設定画面（音楽設定、カスタマイズ、アカウント設定 — すべてUI Only）
- ✅ 実績画面（8件のモック実績、進捗表示）
- ✅ 認証画面（ログイン/サインアップ — UI Only）
- ✅ 2Dキャンバスパーティクルエフェクト（マウスインタラクション付き）
- ✅ 3Dエフェクト群（Scene3D, ParticleSystem, FloatingLeaves等 — 未使用）

### 未実装（バックエンド・コア機能）

- ❌ 認証システム（Supabase等）
- ❌ 音声再生エンジン（BGM・環境音）
- ❌ データ永続化（ユーザー設定、進捗、実績）
- ❌ ポモドーロタイマーの実動作（バックエンド連携）
- ❌ キャラクター/部屋カスタマイズの実体
- ❌ 精霊収集システム
- ❌ パフォーマンス最適化（長時間稼働対応）

---

## 🧠 Step 1: Web化における「技術的・体験的課題」— 7名の専門家ディスカッション

### 参加者

| #   | ペルソナ                                | 略称 |
| --- | --------------------------------------- | ---- |
| 1   | プロダクトマネージャー                  | PM   |
| 2   | テックリード / フロントエンドエンジニア | TL   |
| 3   | バックエンド / インフラエンジニア       | BE   |
| 4   | UI/UXデザイナー                         | UX   |
| 5   | ゲームデザイナー                        | GD   |
| 6   | サウンド・クリエイティブディレクター    | SD   |
| 7   | QA/リリースマネージャー                 | QA   |

---

### 🔥 議題1: ブラウザのタブ休止・バックグラウンド制限

**TL（テックリード）**: 最大の敵は **Chrome の Tab Throttling と Tab Discarding** だ。ユーザーがタブをバックグラウンドにした瞬間、`requestAnimationFrame` は停止し、`setInterval`/`setTimeout` は最低1秒間隔に制限される。さらに5分以上バックグラウンドだとタブがフリーズ（Discarded）される可能性がある。ポモドーロタイマーの「正確な時間計測」はこれで破綻する。

**SD（サウンド）**: 音声も同じ問題がある。バックグラウンドタブでは `AudioContext` の処理が間引かれる。BGMが途切れたり、テンポがズレたりする。ユーザーは「音楽を流しながら別タブで作業する」想定なので、これは致命的だ。

**BE（バックエンド）**: 解決策は3つある:

1. **Web Worker** — タイマーロジックをメインスレッドから分離。Worker内の `setInterval` はThrottling の影響を受けにくい
2. **Service Worker** — バックグラウンドでも動作継続。ただしライフサイクル管理が複雑
3. **サーバーサイドタイムスタンプ** — 開始時刻をDBに記録し、復帰時にサーバー時刻と比較。最も信頼性が高い

**PM**: 現実的には **Web Worker + サーバーサイドタイムスタンプのハイブリッド** がベストだろう。フロントで精度の良い表示をしつつ、バックエンドで真の経過時間を保証する。

**QA**: Safari と Firefox でも検証が必要。特に Safari は Web Audio API のバックグラウンド挙動が Chrome と異なる。iOS Safari は完全にオーディオを停止させる場合がある。

#### ✅ 決定事項

- ポモドーロタイマー: **Web Worker + サーバーサイドタイムスタンプ** のハイブリッド方式
- バックグラウンド復帰時: サーバー時刻で補正 + 通知表示
- 音声: `AudioContext` の `state` を監視し、復帰時に自動 `resume()`

---

### 🔥 議題2: オーディオ自動再生ポリシー

**SD**: 全モダンブラウザが `Autoplay Policy` を実装している。ユーザーの明示的なジェスチャー（クリック/タップ）なしに音声は再生できない。「ページを開いたらLofiが流れる」体験はそのままでは実現不可能。

**UX**: ここはUXで解決する。**ランディング画面に「Enter / 部屋に入る」ボタンを配置**し、そのクリックイベント内で `AudioContext` を初期化する。Spirit City本家もゲーム開始ボタンがあるから、ユーザーに違和感はないはず。

**TL**: 技術的にはこう実装する:

```typescript
// ユーザーの最初のクリックで AudioContext を unlock
const audioContext = new AudioContext()
document.addEventListener(
  'click',
  () => {
    if (audioContext.state === 'suspended') {
      audioContext.resume()
    }
  },
  { once: true }
)
```

**GD（ゲームデザイナー）**: むしろ「入室」の演出として活かせる。フェードインで音が始まり、パーティクルが舞い始める。没入感のトリガーにできる。

#### ✅ 決定事項

- 「部屋に入る」ボタンを起点に `AudioContext` を初期化
- ランディング → 入室トランジション演出でUX的にカバー
- `AudioContext.state` の監視と自動復帰ロジックを実装

---

### 🔥 議題3: アセットのロード時間・初回表示速度

**TL**: 現状の依存関係に `three.js` (181.2) と `@react-three/fiber` がある。Three.js だけで **~600KB (gzipped ~150KB)** 。3Dエフェクト群（Scene3D等）は現在未使用だが、使用するならバンドルサイズが大幅に増える。

**BE**: 音声ファイルも大きい。Lofi BGM1曲（3〜5分）を192kbps MP3で想定すると **3〜7MB/曲** 。環境音4種類 + BGM4曲で **合計30〜50MB** になりうる。

**PM**: 初回ロードで全部読むのは論外。段階的ローディング戦略が必要だ。

**TL**: 以下の戦略を提案する:

1. **コード分割**: Three.js関連は `dynamic import` で遅延ロード。初回バンドルから除外
2. **音声ストリーミング**: `<audio>` タグの `preload="none"` + ユーザー操作時に `fetch` + `AudioBuffer`
3. **Service Worker キャッシュ**: 一度読み込んだ音声/アセットをキャッシュ。2回目以降は瞬時ロード
4. **プログレッシブ表示**: スケルトンUI → 背景 → UIコンポーネント → 音声（順次表示）

**UX**: ローディング画面自体も体験にする。木漏れ日のアニメーションとローディングバーで「世界に入っていく」感覚を演出できる。

**SD**: 音声は **OGG Vorbis（~128kbps）** を基本とし、非対応ブラウザ向けに MP3 フォールバックを用意する。OGGなら同品質でMP3の60〜70%のサイズになる。さらに環境音は **30秒〜1分のシームレスループ** に切り出せば、1ファイル500KB〜1MB に収まる。

#### ✅ 決定事項

- Three.js は `next/dynamic` で遅延ロード（初回バンドルから除外）
- 音声: OGG Vorbis優先 + MP3フォールバック、ストリーミング再生
- 環境音: 30秒〜1分のシームレスループファイル
- Service Worker によるアセットキャッシュ戦略
- プログレッシブローディングUI

---

### 🔥 議題4: メモリリーク・長時間稼働の安定性

**TL**: ユーザーは8時間以上タブを開きっぱなしにする。メモリリークは確実にクラッシュを引き起こす。現状のコードを確認すると、`CanvasParticles.tsx` で **300個のパーティクルを毎フレーム再描画** しており、`useEffect` のクリーンアップが不完全な箇所がある可能性が高い。

**BE**: 具体的なリスクポイント:

1. **Canvas 2D の再描画ループ** — `requestAnimationFrame` のキャンセル忘れ
2. **Framer Motion のアニメーション** — コンポーネントのアンマウント時にアニメーションが残留
3. **イベントリスナー** — `mousemove`, `resize` のリスナー解除漏れ
4. **AudioContext のノード蓄積** — 再生のたびに `createBufferSource` を呼ぶと GainNode 等が蓄積

**TL**: 対策:

1. **パーティクル数の動的調整**: Performance Observer APIでFPSを監視し、低下したらパーティクル数を削減
2. **`useEffect` のクリーンアップ徹底**: ESLintルール `react-hooks/exhaustive-deps` に加え、カスタムルールを検討
3. **AudioNode のプーリング**: 再利用可能なノードプールを実装
4. **定期的なメモリ計測**: `performance.memory`（Chrome）でヒープサイズを監視、閾値超えで軽量モードに切替

**QA**: 8時間連続稼働テストをCI/CDに組み込むべき。Playwright で「8時間放置 → メモリ使用量チェック」の自動テストを作る。

#### ✅ 決定事項

- パーティクル数の動的FPS調整システム
- 全コンポーネントの `useEffect` クリーンアップ監査
- AudioNode プーリング実装
- 長時間稼働テスト（Playwright）のCI統合

---

### 🔥 議題5: レスポンシブ・モバイル対応

**QA**: 現状のUIはPCレイアウト前提だ。スマホで開いた場合:

1. ポモドーロタイマーの円形UIが小さすぎて操作困難
2. 環境音の4つのスライダーが横並びで画面からはみ出す
3. 3Dエフェクトはモバイルのリソースでは重すぎる

**UX**: Spirit City本家はPC専用だが、Webサービスならモバイル対応は必須。ただし **「フル機能のモバイル版」ではなく「モバイル向け軽量版」** というアプローチを取るべき。

- モバイル: タイマー + BGM再生 + 簡素な背景（パーティクル無し）
- PC: フル機能（3D/2Dエフェクト、カスタマイズ、精霊収集）

**TL**: 具体的にはメディアクエリとデバイス判定で分岐:

```typescript
const isMobile = window.matchMedia('(max-width: 768px)').matches
const particleCount = isMobile ? 50 : 300
const enable3D = !isMobile
```

**GD**: モバイルでは精霊収集のような複雑なシステムは省略し、「タイマー + BGM + 簡単な統計」に絞る。PWA化すればホーム画面に追加もできるし、「作業BGMアプリ」としての需要も取れる。

**PM**: フェーズ1はPC優先。モバイルはフェーズ2でPWA対応として実装する。ただし、初期からレスポンシブなベースレイアウトだけは担保しておく。

#### ✅ 決定事項

- フェーズ1: PCファースト（最低限レスポンシブなベースレイアウト）
- フェーズ2: モバイル対応（PWA、軽量版UI、パーティクル削減）
- デバイス判定に基づくエフェクト・機能の出し分け

---

### 🔥 議題6: オフライン対応・通信不安定時の挙動

**BE**: 「作業中にWi-Fiが切れた」シナリオ。タイマーは継続すべきだし、BGMも途切れてほしくない。

**TL**: Service Worker を活用した **オフラインファースト設計**:

1. 一度再生した音声はキャッシュ → オフラインでも再生可能
2. タイマーデータはローカル（IndexedDB）に保存 → オンライン復帰時にサーバーと同期
3. UIアセットはビルド時にプリキャッシュ

**SD**: 音声のバッファリング戦略も重要。現在再生中の曲 + 次の曲をプリフェッチしておく。回線が途切れても2曲分は再生し続けられる。

**QA**: オフライン時にはUI上に控えめな通知（「オフラインモード — 復帰時にデータを同期します」）を表示すべき。

#### ✅ 決定事項

- Service Worker によるオフラインファースト設計
- IndexedDB でローカルデータ永続化 + オンライン同期
- 音声プリフェッチ（現在の曲 + 次の曲）
- オフライン通知UI

---

### 🔥 議題7: 音声ループの品質・ライセンス

**SD**: 音声の品質について重要な議論がある:

1. **ループの継ぎ目**: BGMは **完全シームレスループ** でなければならない。MP3フォーマットはエンコーダーの都合で先頭/末尾に無音が入る。**OGG/WebM** ならギャップレス再生が可能
2. **環境音のクロスフェード**: 「雨」→「焚き火」の切替時に自然なクロスフェードが必要。`GainNode` の `linearRampToValueAtTime` で実装
3. **楽曲ライセンス**: 自作 or ロイヤリティフリー楽曲を使用。CC BY ライセンスのLofiトラックも多数あるが、商用利用可能か個別に確認が必要

**TL**: Web Audio API で実装するループ再生の構造:

```
AudioContext → [BufferSource] → [GainNode(個別)] → [GainNode(マスター)] → Destination
                  ↑ ループ設定         ↑ 個別音量              ↑ マスター音量
```

環境音は複数同時再生し、BGMは1トラックのみ。全体で **最大5チャネル同時再生** （BGM1 + 環境音4）。

**PM**: フェーズ1ではフリー音源 or プレースホルダーでリリースし、フェーズ2でオリジナル楽曲を制作委託する方針でよいか？

**SD**: 賛成。ただしフェーズ1でも **音響体験の基盤（Web Audio APIのアーキテクチャ）は本番品質で作り込む** べき。音源を差し替えるだけで済むようにする。

#### ✅ 決定事項

- Web Audio API ベースの音声エンジン（BufferSource + GainNode構成）
- OGG/WebM優先（ギャップレスループ対応）、MP3フォールバック
- 環境音クロスフェード（linearRampToValueAtTime）
- フェーズ1: フリー/CC音源、フェーズ2: オリジナル楽曲
- 最大5チャネル同時再生（BGM×1 + 環境音×4）

---

## 📅 Step 2: マイルストーン計画

### Milestone 0: 基盤整備・アーキテクチャ設計

> 現在のモックUIを本番アーキテクチャに載せ替える

- [ ] **M0-1**: プロジェクト設計ドキュメント作成（アーキテクチャ図、データモデル、API設計）
- [ ] **M0-2**: Supabase プロジェクトセットアップ（認証、DB、Storage）
- [ ] **M0-3**: DBスキーマ設計・マイグレーション
  - users, sessions, achievements, user_settings, spirits テーブル
- [ ] **M0-4**: 認証フロー実装（Supabase Auth — Email + OAuth Google/GitHub）
  - 既存のログイン/サインアップUIと接続
- [ ] **M0-5**: CI/CD パイプライン構築（Vercel + GitHub Actions）
  - Lint → Build → Test → Deploy（Preview / Production）
- [ ] **M0-6**: ESLint / Prettier 設定強化、React hooks ルール厳格化

---

### Milestone 1: コアエンジン実装

> 音声エンジンとタイマーエンジン — サービスの心臓部

- [ ] **M1-1**: Web Audio API 音声エンジン構築
  - AudioContext 管理クラス（シングルトン）
  - BufferSource + GainNode のチャネル構成
  - マスター音量 / 個別音量制御
  - OGG/MP3 デコード + フォーマット判定
- [ ] **M1-2**: BGMループ再生システム
  - ギャップレスループ（OGG優先）
  - トラック切替時のクロスフェード
  - プレイリスト順次再生 / シャッフル
- [ ] **M1-3**: 環境音ミキシングシステム
  - 4チャネル同時再生（雨/森/海/焚火）
  - 個別音量スライダーとの連動
  - クロスフェードON/OFF切替
- [ ] **M1-4**: AudioContext ライフサイクル管理
  - ユーザージェスチャーによる初期化（「部屋に入る」ボタン）
  - バックグラウンド時の `suspend` / フォアグラウンド復帰時の `resume`
  - AudioNode プーリング（メモリリーク防止）
- [ ] **M1-5**: ポモドーロタイマーエンジン（Web Worker）
  - Web Worker 内でのタイマーロジック
  - メインスレッドとの `postMessage` 通信
  - サーバーサイドタイムスタンプとの同期
  - 作業/休憩サイクル管理（25/5, 50/10 等カスタマイズ）
- [ ] **M1-6**: タイマーセッション記録
  - セッション開始/終了をSupabaseに記録
  - 日次/週次/月次の作業統計集計

---

### Milestone 2: UI/UXリファイン & データ連携

> モックUIを実データに接続し、体験を磨く

- [ ] **M2-1**: 「入室」ランディング画面実装
  - フェードイン演出 + AudioContext 初期化トリガー
  - ローディングプログレス表示
- [ ] **M2-2**: 設定画面のデータ永続化
  - ユーザー設定をSupabase に保存/読出し
  - BGM音量、環境音設定、テーマ、カスタマイズ選択
- [ ] **M2-3**: 進捗・統計画面の実データ表示
  - XP / レベルシステム計算ロジック
  - 作業時間に基づくXP付与
  - レベルアップ演出（アニメーション + サウンドエフェクト）
- [ ] **M2-4**: 実績システム実装
  - 実績条件の定義（JSON or DB）
  - 条件達成時のアンロック処理
  - トースト通知 + 実績画面への反映
- [ ] **M2-5**: パーティクルエフェクトの最適化
  - FPS監視による動的パーティクル数調整
  - `useEffect` クリーンアップの徹底監査
  - 未使用3Dコンポーネントの整理（使うか削除するか決定）
- [ ] **M2-6**: テーマ切替の体験改善
  - テーマに応じた背景アニメーション変化
  - テーマに応じたパーティクル色・挙動変化
  - トランジションアニメーション強化

---

### Milestone 3: 精霊収集 & ゲーミフィケーション

> Spirit City の核心的体験をWeb化

- [ ] **M3-1**: 精霊（Spirit）データモデル設計
  - 精霊マスターデータ（名前、タイプ、レアリティ、出現条件）
  - ユーザーの精霊コレクション管理
- [ ] **M3-2**: 精霊出現ロジック
  - 作業時間に応じた出現確率計算
  - 時間帯/テーマ/環境音による出現種類の変化
  - 出現演出アニメーション
- [ ] **M3-3**: 精霊コレクション画面
  - 図鑑UI（収集済み/未収集）
  - 精霊詳細表示（イラスト、説明、出現条件ヒント）
- [ ] **M3-4**: 精霊のインタラクション
  - 部屋に配置された精霊の表示
  - クリック/ホバーでのリアクション
  - お気に入り精霊の設定
- [ ] **M3-5**: 部屋カスタマイズの実体化
  - 背景の実アセット（イラスト or 生成AI）
  - 家具/デコレーション配置システム
  - カスタマイズのプレビュー + 保存

---

### Milestone 4: パフォーマンス・安定性・テスト

> 長時間稼働の信頼性を確保

- [ ] **M4-1**: Service Worker 実装
  - UIアセットのプリキャッシュ（Workbox）
  - 音声ファイルのランタイムキャッシュ
  - オフライン時の Fallback UI
- [ ] **M4-2**: IndexedDB によるローカルデータ永続化
  - タイマーセッション / 設定のオフライン保存
  - オンライン復帰時のサーバー同期
- [ ] **M4-3**: メモリリーク対策の実装・検証
  - 全コンポーネントのクリーンアップ監査
  - Chrome DevTools Memory タブでのヒープスナップショット分析
  - 8時間連続稼働テスト
- [ ] **M4-4**: バンドルサイズ最適化
  - Three.js の dynamic import 化
  - Tree shaking の確認
  - Lighthouse パフォーマンススコア 90+ 目標
- [ ] **M4-5**: ブラウザ互換性テスト
  - Chrome / Safari / Firefox / Edge
  - Web Audio API の挙動差分対応
  - iOS Safari の制約対応（オーディオ自動再生、バックグラウンド制限）
- [ ] **M4-6**: E2Eテスト整備（Playwright）
  - 基本フロー（入室 → BGM再生 → タイマー開始 → セッション完了）
  - 長時間稼働テスト（メモリ使用量監視）
  - オフライン/オンライン切替テスト

---

### Milestone 5: β版リリース & フィードバック

> 限定公開でリアルユーザーのフィードバックを収集

- [ ] **M5-1**: β版ランディングページ作成
  - サービス紹介 / スクリーンショット / 機能説明
  - ウェイトリスト登録フォーム
- [ ] **M5-2**: β版デプロイ（Vercel）
  - 招待制アクセス制御
  - フィードバックウィジェット埋め込み
  - エラー監視（Sentry）
  - アナリティクス（Vercel Analytics / Mixpanel）
- [ ] **M5-3**: β版フィードバック収集・分析
  - ユーザーインタビュー
  - 使用状況データ分析
  - 優先度つきバグ/改善リスト作成
- [ ] **M5-4**: β版フィードバック対応
  - クリティカルバグ修正
  - UX改善（フィードバックベース）

---

### Milestone 6: 正式リリース

> パブリックリリースとグロース施策

- [ ] **M6-1**: 正式版ランディングページ
  - SEO最適化
  - OGP / Social Media 対応
- [ ] **M6-2**: モバイル対応（PWA）
  - レスポンシブレイアウト完成
  - PWA マニフェスト + Install Prompt
  - モバイル向け軽量版エフェクト
- [ ] **M6-3**: 多言語対応（i18n）
  - 日本語 / 英語（最低限）
  - next-intl or next-i18next 導入
- [ ] **M6-4**: 正式版デプロイ & 監視体制確立
  - 本番環境のモニタリングダッシュボード
  - アラート設定（エラー率、レスポンスタイム）
  - バックアップ/リカバリ手順

---

## ⚠️ リスク・注意事項

| リスク                    | 影響度 | 対策                                                 |
| ------------------------- | ------ | ---------------------------------------------------- |
| Three.js のバンドルサイズ | 高     | dynamic import、必要最小限のモジュールのみimport     |
| iOS Safari の音声制限     | 高     | ジェスチャー起点の初期化、フォアグラウンド必須の明示 |
| 長時間稼働のメモリリーク  | 高     | Web Worker分離、定期メモリチェック、自動軽量モード   |
| 音源のライセンス問題      | 中     | CC BY/CC0 の確認、自作音源の制作委託                 |
| Supabase の無料枠上限     | 中     | 初期はFree Tier、ユーザー増加時にPro移行計画         |

---

## 📝 備考

- 現状のコードベースはUIモックとして非常に完成度が高い。テーマシステム（9種）、アニメーション、パーティクルエフェクトはそのまま活用可能
- 未使用の3Dコンポーネント群（Scene3D, FloatingLeaves, ParticleSystem等）は M2-5 で使用/削除を判断
- `@react-three/fiber` と `three` はバンドルサイズが大きいため、不使用なら依存関係から削除も検討

　
